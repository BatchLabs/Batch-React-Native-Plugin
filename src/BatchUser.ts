import { NativeModules } from 'react-native';

import { BatchEventData } from './BatchEventData';
import { BatchUserAttribute } from './BatchUserAttribute';
import { BatchUserEditor } from './BatchUserEditor';
import Log from './helpers/Logger';
import { isNumber, isString } from './helpers/TypeHelpers';

const RNBatch = NativeModules.RNBatch;

/**
 * Represents a locations, using lat/lng coordinates
 */
export interface Location {
  /**
   * Latitude
   */
  latitude: number;

  /**
   * Longitude
   */
  longitude: number;

  /**
   * Date of the tracked location
   */
  date?: Date;

  /**
   * Precision radius in meters
   */
  precision?: number;
}

/**
 * Batch's user module
 */
export const BatchUser = {
  /**
   * Get the unique installation ID, generated by Batch. Batch must be started to read it.
   * You will get the result in a promise.
   */
  getInstallationID: (): Promise<string> => RNBatch.userData_getInstallationId(),

  /**
   * Get the custom user identifier.
   * @returns The custom user identifier set with BatchUser.editor().setIdentifier();
   */

  getIdentifier: (): Promise<string> => RNBatch.userData_getIdentifier(),

  /**
   * Get the region.
   * @returns The region set with BatchUser.editor().setRegion();
   */

  getRegion: (): Promise<string> => RNBatch.userData_getRegion(),

  /**
   * Get the language.
   * @returns The language set with BatchUser.editor().setLanguage();
   */

  getLanguage: (): Promise<string> => RNBatch.userData_getLanguage(),

  /**
   * Read the saved attributes.
   * Reading is asynchronous so as not to interfere with saving operations.
   * @returns The attributes set with Batch.editor().setAttribute()
   */
  getAttributes: (): Promise<{ [key: string]: BatchUserAttribute }> => {
    return RNBatch.userData_getAttributes().then(attributes => {
      Object.keys(attributes).map(key => {
        attributes[key] = new BatchUserAttribute(attributes[key].type, attributes[key].value);
      });
      return attributes;
    });
  },

  /**
   * Get the tag collections.
   * @returns The tags added with BatchUser.editor().addTag()
   */
  getTags: (): Promise<{ [key: string]: Array<string> }> => RNBatch.userData_getTags(),

  /**
   * Creates an editor for the user profile
   * The profile is not updated until the method `save()` is called
   */
  editor: (): BatchUserEditor => new BatchUserEditor(),

  /**
   * Track an event. Batch must be started at some point, or events won't be sent to the server.
   * @param name The event name. Must be a string.
   * @param label The event label (optional). Must be a string.
   * @param data The event data (optional). Must be an object.
   */
  trackEvent: (name: string, label?: string, data?: BatchEventData): void => {
    //TODO (arnaud): Check if "isString" really is necessary. Same for data
    // Since _toInternalRepresentation is private, we have to resort to this little hack to access the method.
    // That syntax keeps the argument type checking, while casting as any would not.
    RNBatch.userData_trackEvent(
      name,
      isString(label) ? label : null,
      data instanceof BatchEventData ? data['_toInternalRepresentation']() : null
    );
  },

  /**
   * Track a transaction. Batch must be started at some point, or events won't be sent to the server.
   * @param amount Transaction's amount.
   * @param data The transaction data (optional). Must be an object.
   */
  trackTransaction: (amount: number, data?: { [key: string]: unknown }): void => {
    if (typeof amount === 'undefined') {
      Log(false, 'BatchUser - Amount must be a valid number. Ignoring transaction.');
      return;
    }

    if (!isNumber(amount) || isNaN(amount)) {
      Log(false, 'BatchUser - Amount must be a valid number. Ignoring transaction.');
      return;
    }

    if (typeof data !== 'object') {
      data = null;
    }

    RNBatch.userData_trackTransaction(amount, data);
  },

  /**
   * Track a geolocation update
   * You can call this method from any thread. Batch must be started at some point, or location updates won't be sent to the server.
   * @param location User location object
   */
  trackLocation: (location: Location): void => {
    if (typeof location !== 'object') {
      Log(false, 'BatchUser - Invalid trackLocation argument. Skipping.');
      return;
    }

    if (typeof location.latitude !== 'number' || isNaN(location.latitude)) {
      Log(false, 'BatchUser - Invalid latitude. Skipping.');
      return;
    }

    if (typeof location.longitude !== 'number' || isNaN(location.longitude)) {
      Log(false, 'BatchUser - Invalid longitude. Skipping.');
      return;
    }

    if (location.precision && (typeof location.precision !== 'number' || isNaN(location.precision))) {
      Log(false, 'BatchUser - Invalid precision. Skipping.');
      return;
    }

    if (location.date && !(location.date instanceof Date)) {
      Log(false, 'BatchUser - Invalid date. Skipping.');
      return;
    }

    RNBatch.userData_trackLocation({
      date: location.date ? location.date.getTime() : undefined,
      latitude: location.latitude,
      longitude: location.longitude,
      precision: location.precision,
    });
  },
};
